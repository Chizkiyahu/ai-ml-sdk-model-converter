//
// SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//

module attributes {tf_saved_model.semantics, tfl.description = "MLIR Converted.", tfl.schema_version = 3 : i32} {
  func.func @main(%arg0: tensor<1x16x16x16xi8> {tf_saved_model.index_path = ["input_1"]}, %arg1: tensor<1x8x8x16xi8> {tf_saved_model.index_path = ["input_3"]}, %arg2: tensor<1x16x16x16xi8> {tf_saved_model.index_path = ["input_2"]}) -> (tensor<1x8x8x16xi8> {tf_saved_model.index_path = ["tf.quantization.fake_quant_with_min_max_vars_4"]}) attributes {tf.entry_function = {inputs = "input_0,input_1,input_2", outputs = "output_0"}, tf_saved_model.exported_names = ["serving_default"]} {
    %0 = tosa.custom %arg0, %arg2 {domain_name = "TFL", implementation_attrs = "entry_point\00\04main\00input<0>_binding\00input<0>_type\00\06TENSOR\00input<0>_vkdescriptortype\00%VK_DESCRIPTOR_TYPE_TENSOR_ARM\00input<0>_vkformat\00\11VK_FORMAT_R8_SINT\00input<1>_binding\00input<1>_type\00\06TENSOR\00input<1>_vkdescriptortype\00%VK_DESCRIPTOR_TYPE_TENSOR_ARM\00input<1>_vkformat\00\11VK_FORMAT_R8_SINT\00input_descriptor_set\00is_vkshader\00output<0>_binding\00output<0>_type\00\06TENSOR\00output<0>_vkdescriptortype\00%VK_DESCRIPTOR_TYPE_TENSOR_ARM\00output<0>_vkformat\00\11VK_FORMAT_R8_SINT\00output_descriptor_set\00workgroup_sizes\00\0816,16,16\00\11\00\10\02\00\02\F1\01\DD\01\9E\01{\01l\01X\01\19\01\F6\00\E3\00\D9\00\C9\00\B4\00t\00P\00<\00\22\00\02\00\11\00+\02\00\00\0A\02\EA\01\B3\01\01\00\85\01e\01.\01\00\00\FF\FF\02\00\E1\00\C0\00\88\00\00\00S\00\14\05\14\14\14\05\14\14\14\05\05\05\14\14\14\05\143%\01", operator_name = "vkshader_pre_custom_op"} : (tensor<1x16x16x16xi8>, tensor<1x16x16x16xi8>) -> tensor<1x16x16x16xi8>
    %1 = tosa.max_pool2d %0 {kernel = array<i64: 2, 2>, pad = array<i64: 0, 0, 0, 0>, stride = array<i64: 2, 2>} : (tensor<1x16x16x16xi8>) -> tensor<1x8x8x16xi8>
    %2 = tosa.custom %arg1, %1 {domain_name = "TFL", implementation_attrs = "entry_point\00\04main\00input<0>_binding\00input<0>_type\00\06TENSOR\00input<0>_vkdescriptortype\00%VK_DESCRIPTOR_TYPE_TENSOR_ARM\00input<0>_vkformat\00\11VK_FORMAT_R8_SINT\00input<1>_binding\00input<1>_type\00\06TENSOR\00input<1>_vkdescriptortype\00%VK_DESCRIPTOR_TYPE_TENSOR_ARM\00input<1>_vkformat\00\11VK_FORMAT_R8_SINT\00input_descriptor_set\00is_vkshader\00output<0>_binding\00output<0>_type\00\06TENSOR\00output<0>_vkdescriptortype\00%VK_DESCRIPTOR_TYPE_TENSOR_ARM\00output<0>_vkformat\00\11VK_FORMAT_R8_SINT\00output_descriptor_set\00workgroup_sizes\00\068,8,16\00\11\00\0E\02\FE\01\EF\01\DB\01\9C\01y\01j\01V\01\17\01\F4\00\E1\00\D7\00\C7\00\B2\00r\00N\00:\00\22\00\02\00\11\00)\02\00\00\08\02\E8\01\B1\01\01\00\83\01c\01,\01\00\00\FF\FF\02\00\DF\00\BE\00\86\00\00\00Q\00\14\05\14\14\14\05\14\14\14\05\05\05\14\14\14\05\143%\01", operator_name = "vkshader_post_custom_op"} : (tensor<1x8x8x16xi8>, tensor<1x8x8x16xi8>) -> tensor<1x8x8x16xi8>
    return %2 : tensor<1x8x8x16xi8>
  }
}
